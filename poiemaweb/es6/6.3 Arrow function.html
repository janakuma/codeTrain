<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>화살표 함수</title>
	<style>
		* {margin: 0; padding: 0;}
		body {
			line-height: 2;
			font-size: 14px;
			font-family: 'dotum';
		}

		.wrapper {
			width: 1080px;
			margin: 0 auto;
			padding: 50px;
		}

		h3 { margin-top: 100px; font-size: 24px;}
		h3:nth-of-type(1) { margin-top: 0;  }
		h4 { margin-top: 50px; font-size: 18px;}
		p {margin-top: 20px;}

		pre {
			margin: 20px 0 0 0;
			padding: 20px;
			border: 1px solid #666;
			background-color: #eaeaea;
		}


	</style>
</head>
<body>

<div class="wrapper">
<h3>1. 화살표 함수의 선언</h3>

//매개변수 지정 방법
() => { ... } //매개변수가 없을 경우
x => { ... } //매개변수가 한 개인 경우, 소괄호를 생략할 수 있다.
(x, y) => { ... } //매개변수가 여러개인 경우, 소괄호를 생략할 수 없다.

//함수 몸체 지정 방법
x => { return x * x }; //single line block;
x => x * x; //함수 몸체가 한줄의 구문이라면 중괄호를 생량할 수 있으며 암묵적으로 return된다. 위 표현과 동일하다.

() => { return { a:1 }; }
() => ({ a:1 }) // 위 표현과 동일하다. 객체 반환시 소괄호를 사용한다.

() => { //multiple line block
	const x = 10;
	return x * x;
}

<h3>2. 화살표 함수의 호출</h3>
<p>화살표 함수는 익명함수로만 사용할 수 있다. 따라서 화살표 함수를 호출하기 위해서는 함수 표현식을 사용한다.</p>

<pre>
// ES5
var pow = function (x) { return x * x };
console.log(pow(10));

// ES6
const pow = x => x * x;
console.log(pow(10)); //100

또는 콜백 함수로 사용할 수 있다. 이 경우 일반적인 함수 표현식보다 표현이 간결하다.

// ES5
var arr = [1,2,3];
var pow = arr.map(function (x) { //x는 요소값
	return x * x;
});
console.log(pow); [1,4,9];

// ES6
const arr = [1,2,3];
const pow = arr.map(x => x * x); //return 문을 이와 같은 식으로 변경 가능

console.log(pow); //[1,4,9];
</pre>

<h3>3. this</h3>
function 키워드로 생성한 일반 함수와 화살표 함수의 가장 큰 차이점은 this이다.

<h4>3.1 일반 함수의 this</h4>
<p>
	자바스크립으 경우 함수 호출 방식에 의해 this에 바인딩할 어떤 객체가 동적으로 결정되다. 다시 말해, 함수를 선언할 때 this에 바인딩할 객체가 정적으로 결정 되는 것이 아니고,
	<strong>함수를 호출할 때 함수가 어떻게 호출되었는지에 따라</strong> this에 바인딩할 객체가 동적으로 결정된다.
</p>
<p>
	콜백 함수 내부의 this는 전역 객체 window를 가리킨다.
</p>

화살표 함수는 생성자 함수로 사용할 수 없다.




</body>
</html>